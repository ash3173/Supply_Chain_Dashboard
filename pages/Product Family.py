import streamlit as st
import requests
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots

st.set_page_config(
    layout="wide",
    initial_sidebar_state="expanded",
    )

def plot_revenue(data):
    """
    Plot revenue data for multiple business units over time as subplots in a single Plotly figure.

    Args:
    data (dict): A dictionary where keys are business unit names and values are lists of revenue over time.

    Returns:
    fig: A Plotly figure with subplots.
    """
    # Number of business units
    num_business_units = len(data)

    # Create subplots layout
    fig = make_subplots(
        rows=1,  # Single row
        cols=num_business_units,  # One column per business unit
        subplot_titles=list(data.keys())  # Titles for each subplot
    )

    # Colors for the plots
    colors = [
        "rgba(33,150,243,1)",  # Blue
        "rgba(76,175,80,1)",   # Green
        "rgba(255,152,0,1)",   # Orange
        "rgba(156,39,176,1)",  # Purple
        "rgba(255,193,7,1)",   # Yellow
        "rgba(0,188,212,1)",   # Cyan
        "rgba(121,85,72,1)",   # Brown
        "rgba(96,125,139,1)"   # Grey
    ]

    # Add traces for each business unit
    for i, (business_unit, revenues) in enumerate(data.items()):
        fig.add_trace(
            go.Scatter(
                x=list(range(len(revenues))),
                y=revenues,
                mode='lines',
                fill='tozeroy',  # Adds shading under the line
                name=business_unit,
                line=dict(color=colors[i % len(colors)], width=2),
                fillcolor=colors[i % len(colors)].replace(",1)", ",0.2)")  # Adjust alpha for transparency
            ),
            row=1,  # Single row
            col=i + 1  # Column index
        )

    # Customize the layout
    fig.update_layout(
        title='Revenue Generated by Product Family Over Time',
        title_x=0,  # Center the title
        height=300,  # Set custom height
        width=500 * num_business_units,  # Dynamically adjust width based on the number of subplots
        template='plotly_dark',  # Dark mode theme
        showlegend=False,  # Hide legend (each subplot has its title)
        margin=dict(t=50, b=30, l=30, r=30)  # Adjust margins
    )

    # Update subplot titles font size
    fig.update_annotations(font_size=12)

    return fig


    



def plot_higest_revenue(revenue, identifier,q):

    fig, ax = plt.subplots(figsize=(4, 4), facecolor='none')
    ax.set_xlim(-1, 1)
    ax.set_ylim(-1, 1)
    
    circle = Circle((0, 0.5), 0.4, edgecolor='#2596be', facecolor='none', linewidth=6)
    ax.add_artist(circle)
    
    ax.text(
        0, 0.5, identifier, 
        fontsize=16, ha='center', va='center', color='#2596be', style='italic', weight='bold'
    )
    
    ax.text(
        0, -0.2, f"Revenue : {revenue}", 
        fontsize=12, ha='center', va='center', color='white', style='italic', weight='bold'
    )

    ax.text(
        0, -0.4, f"Quarter : {q}", 
        fontsize=12, ha='center', va='center', color='white', style='italic', weight='bold'
    )    
    
    ax.axis('off')
    fig.patch.set_alpha(0)

    return fig

def main():

    # Adjust global Streamlit styling
    st.markdown("""
    <style>
        .block-container {
            padding-top: 1rem; /* Reduce top padding */
            padding-bottom: 0rem;
        }
        .css-1v3fvcr {
            margin-top: 0rem;
            margin-bottom: 0rem;
        }
    </style>
    """, unsafe_allow_html=True)

    st.title("Product Family Dashboard")
    if "temporal_graph" not in st.session_state:
        st.error("No Temporal Graph found in the session state. Please run the main script first.")
        return
    
    totalTimeStamps=len(st.session_state.temporal_graph.files)

    revenue_of_product_offering_across_time = {}

    for time in range(totalTimeStamps) :

        url_data = requests.get(st.session_state.temporal_graph.files[time])
        if url_data.status_code != 200:
            st.error("Failed to load data from the server.")
            return
        data = url_data.json()

        PRODUCT_FAMILY = data["node_values"]["PRODUCT_FAMILY"]

        for i in range(len(PRODUCT_FAMILY)) :
            if PRODUCT_FAMILY[i][1] not in revenue_of_product_offering_across_time :
                revenue_of_product_offering_across_time[PRODUCT_FAMILY[i][1]] = []

            revenue_of_product_offering_across_time[PRODUCT_FAMILY[i][1]].append(PRODUCT_FAMILY[i][-2])

    highest_quarterly_revenue = [0] * len(revenue_of_product_offering_across_time)
    highest_quarterly_revenue_product_group = [""] * len(revenue_of_product_offering_across_time)

    for k,v in revenue_of_product_offering_across_time.items() :
        s1 = sum(v[:3]) / 3
        s2 = sum(v[3:6]) / 3
        s3 = sum(v[6:9]) / 3
        s4 = sum(v[9:]) / 3

        if s1 > highest_quarterly_revenue[0] :
            highest_quarterly_revenue[0] = s1
            highest_quarterly_revenue_product_group[0] = k

        if s2 > highest_quarterly_revenue[1] :
            highest_quarterly_revenue[1] = s2
            highest_quarterly_revenue_product_group[1] = k

        if s3 > highest_quarterly_revenue[2] :
            highest_quarterly_revenue[2] = s3
            highest_quarterly_revenue_product_group[2] = k

        if s4 > highest_quarterly_revenue[3] :
            highest_quarterly_revenue[3] = s4
            highest_quarterly_revenue_product_group[3] = k

    cols = st.columns(4)

    for i in range(len(highest_quarterly_revenue)) :
        revenue, identifier = highest_quarterly_revenue[i], highest_quarterly_revenue_product_group[i]
        fig = plot_higest_revenue(revenue, identifier, i+1)
        with cols[i]:
            st.pyplot(fig)

    fig = plot_revenue(revenue_of_product_offering_across_time)
    st.plotly_chart(fig, use_container_width=True)

    st.divider()  
    col1, col2=st.columns(2)

    with col1:
    
        # Heading for the Supplier ID Info
        st.write("### Supplier ID Info")

    
if __name__ == "__main__":
    main()